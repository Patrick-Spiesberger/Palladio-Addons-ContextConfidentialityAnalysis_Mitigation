package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.AssemblyContextDetail;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.Attacker;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.context.system.UsageSpecification;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;

import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.AssemblyContextHandler;
import edu.kit.ipd.sdq.kamp4attack.core.contextSelection.ListOperations;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

public class AssemblyContextVulnerability extends AssemblyContextHandler {

	private final AttackVector attackVector;
	private AssemblyContextDetail detail;

	public AssemblyContextVulnerability(final BlackboardWrapper modelStorage, final DataHandlerAttacker dataHandler,
			final AttackVector attackVector) {
		super(modelStorage, dataHandler);
		this.attackVector = attackVector;
	}

	@Override
	protected Optional<CompromisedAssembly> attackComponent(final AssemblyContext component,
			final CredentialChange change, final EObject source, Attacker attacker) {
		final var credentials = this.getCredentials(change);
		final var attacks = this.getAttacks();

		final var vulnerabilityList = VulnerabilityHelper
				.getVulnerabilities(this.getModelStorage().getVulnerabilitySpecification(), component);

		// Sets the AttackVector to Local if the AssemblyContextDetail allows it and the
		// component is part of an AssmblyContextDetails
		AttackVector vector = (EcoreUtil.equals(component, detail.getCompromisedComponents().get(0))
				|| !detail.isChangeAttackVectorToLocal()) ? this.attackVector : AttackVector.LOCAL;

		ListOperations listHelper = new ListOperations();

		// If only partial lists are returned, this is executed until all lists are
		// returned or a vulnerable component is found
		while (!listHelper.returnedAllElements()) {
			for (List<UsageSpecification> credential : listHelper.calculateLists(credentials, attacker)) {
				final var vulnerability = this.checkVulnerability(component, change, credential, attacks,
						vulnerabilityList, vector, attacker);
				final var handling = new VulnerabilityHandlingAssemblyContext(this.getDataHandler());
				Optional<CompromisedAssembly> assembly = handling.executeVulnerabilityHandling(component, change,
						source, vulnerability, attacker);

				if (assembly.isPresent()) {
					return assembly;
				}
			}
		}
		return Optional.empty();
	}

	@Override
	protected Optional<CompromisedAssembly> attackComponent(AssemblyContextDetail componentDetail,
			CredentialChange change, EObject source, Attacker attacker) {
		final var credentials = this.getCredentials(change);
		final var attacks = this.getAttacks();
		this.detail = componentDetail;

		for (AssemblyContext component : componentDetail.getCompromisedComponents()) {
			final var vulnerabilityList = VulnerabilityHelper
					.getVulnerabilities(this.getModelStorage().getVulnerabilitySpecification(), component);

			// Sets the AttackVector to Local if the AssemblyContextDetail allows it and if
			// there are subcomponents
			AttackVector vector = (componentDetail.getCompromisedComponents().size() == 1
					|| !componentDetail.isChangeAttackVectorToLocal()) ? this.attackVector : AttackVector.LOCAL;

			ListOperations listHelper = new ListOperations();

			// If only partial lists are returned, this is executed until all lists are
			// returned or a vulnerable component is found
			while (!listHelper.returnedAllElements()) {
				for (List<UsageSpecification> credential : listHelper.calculateLists(credentials, attacker)) {
					final var vulnerability = this.checkVulnerability(component, change, credential, attacks,
							vulnerabilityList, vector, attacker);
					final var handling = new VulnerabilityHandlingAssemblyContext(this.getDataHandler());
					Optional<CompromisedAssembly> assembly = handling.executeVulnerabilityHandling(component, change,
							source, vulnerability, attacker);

					if (assembly.isPresent()) {
						return assembly;
					}
				}
			}
		}
		return Optional.empty();
	}
}
