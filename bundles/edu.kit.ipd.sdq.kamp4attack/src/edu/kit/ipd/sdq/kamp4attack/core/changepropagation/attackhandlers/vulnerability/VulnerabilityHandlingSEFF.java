package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.HelperCreationCompromisedElements;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandler;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.ServiceRestriction;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.repository.Signature;
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF;
import org.palladiosimulator.pcm.seff.ServiceEffectSpecification;

import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;

public class VulnerabilityHandlingSEFF extends VulnerabilityHandling<CompromisedAssembly> {

    private final AssemblyContext assemblyContext;
    private final DataHandlerAttacker dataHandler;

    public VulnerabilityHandlingSEFF(final AssemblyContext assemblyContext, final DataHandlerAttacker dataHandler) {
        this.assemblyContext = assemblyContext;
        this.dataHandler = dataHandler;
    }

    @Override
    protected Optional<CompromisedAssembly> handleTakeOver(final EObject container, final EObject source,
            final Vulnerability vulnerability) {
        if (container instanceof ServiceRestriction) {
            final var specification = (ServiceRestriction) container;

            if (!checkService(specification)) {
                throw new IllegalStateException("Missmatch Service and AssemblyContext");
            }
            final var resource = HelperCreationCompromisedElements.createCompromisedAssembly(this.assemblyContext,
                    List.of(source, vulnerability));
            return Optional.of(resource);
        }
        throw new IllegalStateException("Wrong datatype " + this);
    }

    @Override
    protected void handleConfidentiality(final EObject container) {
        if (container instanceof ServiceRestriction) {
            final var specification = (ServiceRestriction) container;
            final var seff = getSEFF(specification.getSignature(), this.assemblyContext);
            if (seff instanceof ResourceDemandingSEFF) {
                this.dataHandler
                        .addData(DataHandler.getData(specification));
            }
            return;
        }
        throw new IllegalStateException("Wrong datatype " + this);
    }

    private ServiceEffectSpecification getSEFF(final Signature sig, final AssemblyContext ac) {
        final var bc = (BasicComponent) ac.getEncapsulatedComponent__AssemblyContext();
        final var seffList = bc.getServiceEffectSpecifications__BasicComponent();
        for (final ServiceEffectSpecification seff : seffList) {
            if (seff.getDescribedService__SEFF().getEntityName().equals(sig.getEntityName())) {
                return seff;
            }
        }
        return null;
    }

    private boolean checkService(final ServiceRestriction specification) {
        return EcoreUtil.equals(this.assemblyContext, specification.getAssemblycontext());
    }

}
