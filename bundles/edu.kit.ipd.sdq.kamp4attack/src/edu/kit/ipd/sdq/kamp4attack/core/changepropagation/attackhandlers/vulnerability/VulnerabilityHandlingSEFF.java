package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.HelperCreationCompromisedElements;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandler;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.AssemblyContextDetail;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Attack;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.ServiceRestriction;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.repository.Signature;
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF;
import org.palladiosimulator.pcm.seff.ServiceEffectSpecification;

import com.google.common.collect.Iterables;

import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

/**
 * 
 * This class implements handling of a successfully executed vulnerability on
 * SEFF
 * 
 * @author Maximilian Walter
 * @author Patrick Spiesberger
 *
 */
public class VulnerabilityHandlingSEFF extends VulnerabilityHandling<CompromisedAssembly> {

	private final AssemblyContextDetail assemblyContext;
	private final DataHandlerAttacker dataHandler;

	public VulnerabilityHandlingSEFF(final AssemblyContextDetail assemblyContext,
			final DataHandlerAttacker dataHandler) {
		this.assemblyContext = assemblyContext;
		this.dataHandler = dataHandler;
	}

	@Override
	protected Optional<CompromisedAssembly> handleTakeOver(final EObject container, final EObject source,
			final Vulnerability vulnerability) {
		if (container instanceof ServiceRestriction) {
			final var specification = (ServiceRestriction) container;

			if (!checkService(specification)) {
				throw new IllegalStateException("Missmatch Service and AssemblyContext");
			}

			final var resource = HelperCreationCompromisedElements.createCompromisedAssembly(
					Iterables.getLast(assemblyContext.getCompromisedComponents()), assemblyContext,
					List.of(source, vulnerability));
			return Optional.of(resource);
		}
		throw new IllegalStateException("Wrong datatype " + this);
	}

	@Override
	protected void handleConfidentiality(final EObject container, CredentialChange change, List<Attack> attacks) {
		if (container instanceof ServiceRestriction) {
			final var specification = (ServiceRestriction) container;
			final var seff = getSEFF(specification.getSignature(), this.assemblyContext);
			if (seff instanceof ResourceDemandingSEFF) {
                this.dataHandler
                        .addData(DataHandler.getData(specification, change));
            }
            return;
		}
		throw new IllegalStateException("Wrong datatype " + this);
	}

	private ServiceEffectSpecification getSEFF(final Signature sig, final AssemblyContextDetail ac) {
		final var bc = (BasicComponent) Iterables.getLast(this.assemblyContext.getCompromisedComponents())
				.getEncapsulatedComponent__AssemblyContext();
		final var seffList = bc.getServiceEffectSpecifications__BasicComponent();
		for (final ServiceEffectSpecification seff : seffList) {
			if (seff.getDescribedService__SEFF().getEntityName().equals(sig.getEntityName())) {
				return seff;
			}
		}
		return null;
	}

	private boolean checkService(final ServiceRestriction specification) {
		return Iterables.getLast(this.assemblyContext.getCompromisedComponents()).getId()
				.equals(specification.getAssemblycontext().getId());
	}

}
