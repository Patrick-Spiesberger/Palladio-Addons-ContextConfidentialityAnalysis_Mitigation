package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.CollectionHelper;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.HelperCreationCompromisedElements;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.Attacker;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.context.system.UsageSpecification;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.ServiceRestriction;

import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.MethodHandler;
import edu.kit.ipd.sdq.kamp4attack.core.contextSelection.ListOperations;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

/**
 * This class implements a concrete attack on Services with consideration of
 * vulnerabilities
 * 
 * @author Maximilian Walter
 * @author Patrick Spiesberger
 *
 */
public class MethodVulnerability extends MethodHandler {

	private final AttackVector attackVector;

	public MethodVulnerability(final BlackboardWrapper modelStorage, final DataHandlerAttacker dataHandler,
			final AttackVector attackVector) {
		super(modelStorage, dataHandler);
		this.attackVector = attackVector;
	}

	@Override
	protected Optional<CompromisedAssembly> attackComponent(final ServiceRestriction restriction,
			final CredentialChange change, final EObject source, Attacker attacker) {
		final var credentials = getCredentials(change);
		final var attacks = getAttacks();

		// find the original methodspecification of the model, necessary later for
		// comparison since
		// the methodspecification contains a unique id
		final var method = CollectionHelper.findOrCreateServiceRestriction(restriction,
				getModelStorage().getVulnerabilitySpecification(), change);

		final var vulnerabilityList = VulnerabilityHelper
				.getVulnerabilities(getModelStorage().getVulnerabilitySpecification(), method);

		ListOperations listHelper = new ListOperations();

		// If only partial lists are returned, this is executed until all lists are
		// returned or a vulnerable component is found
		while (!listHelper.returnedAllElements()) {
			for (List<UsageSpecification> credential : listHelper.calculateLists(credentials, attacker)) {
				final var vulnerability = this.checkVulnerability(method, change, credential, attacks,
						vulnerabilityList, this.attackVector, attacker);

				final var seffHandling = new VulnerabilityHandlingSEFF(
						CollectionHelper.createAssemblyContextDetail(method.getAssemblycontext()), getDataHandler());
				final var tmpReturnValue = seffHandling.executeVulnerabilityHandling(method, change, source,
						vulnerability, attacker.getAttacks());

				if (tmpReturnValue.isPresent()) {
					return tmpReturnValue;
				} else if (vulnerability != null) {// only service compromised but not the component
					final var sourceList = createSource(source, credential);
					final var compromised = HelperCreationCompromisedElements.createCompromisedService(method,
							sourceList);
					var serviceRestrictions = CollectionHelper.filterExistingService(List.of(compromised), change);
					if (!serviceRestrictions.isEmpty()) {
						change.getCompromisedservice().addAll(serviceRestrictions);
						change.setChanged(true);
					}
				}
			}
		}
		return Optional.empty();

	}

}
